<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libfixbuf: Connection-less Collector</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Connection-less Collector </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_doc_noconnect"></a> </p>
<h1><a class="anchor" id="data-buffer"></a>
How-To Use libfixbuf with a Data Buffer</h1>
<p >One may use libfixbuf to read IPFIX records from a data buffer (a <code>uint8_t</code> array or octet array), independent of the transport mdoe. The application must handle all connections and reading, and it passes libfixbuf the octet array to be decoded. The array must contain valid IPFIX and should begin with the standard IPFIX header. Ideally, the application should provide the necessary Templates before any data records to ensure that the application can decode all of the data records.</p>
<p >To use libfixbuf independent of the transport mode, the initial steps are the same as <a href="collect.html">previously described</a>:</p>
<p >The application creates an <a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> using <a class="el" href="public_8h.html#a23b1973cadfc63b05fabe6091ce48875" title="Allocates a new information model.">fbInfoModelAlloc()</a> and adds any additional, vendor-specific information elements using <a class="el" href="public_8h.html#a4244c83afec83db26a1924fda60f57de" title="Adds a single information element to an information model.">fbInfoModelAddElement()</a>, <a class="el" href="public_8h.html#ac2b0be79429a02c8026ce7ea8f9ab2e5" title="Adds multiple information elements in an array to an information model.">fbInfoModelAddElementArray()</a>, <a class="el" href="public_8h.html#af72db51fd417df411a82909c5fd5d84d" title="Adds information specified in the given XML file to the information model.">fbInfoModelReadXMLFile()</a>, or <a class="el" href="public_8h.html#a2bbcf6d4a777ed7e0a2c364e0662b9f3" title="Adds information specified in the given XML data to the information model.">fbInfoModelReadXMLData()</a>.</p>
<p >It creates an <a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> using <a class="el" href="public_8h.html#a19d0dfe113d61cdabf601ca79c3049c8" title="Allocates an empty transport session state container.">fbSessionAlloc()</a>. For each record to be read, it allocates a <a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> (<a class="el" href="public_8h.html#ad29df497298e072387af52c3a758f268" title="Allocates a new empty template.">fbTemplateAlloc()</a>) and specifies its information elements (<a class="el" href="public_8h.html#afdf4a52e9f867433d46a1d4d8ec4bc8f" title="Appends information elements described by a specifier array to a template.">fbTemplateAppendSpecArray()</a>, <a class="el" href="public_8h.html#aa26aa2d6a6b57dba79d2b5742b4a7540" title="Potentially appends an information element described by the specifier to a template.">fbTemplateAppendSpec()</a>, or <a class="el" href="public_8h.html#a72db5a960f00cd94e223d0fc6b7df0a4" title="Appends an information element to a template.">fbTemplateAppend()</a>) and adds each Template as internal to the Session via <a class="el" href="public_8h.html#a5a23a76ff4edff6616b5db2fbd63644f" title="Adds a Template to a Session.">fbSessionAddTemplate()</a>.</p>
<p >The application should NOT create an <a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a>. To create the <a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a>, use <a class="el" href="public_8h.html#a4dcbc472c9fc394ecb23e1b6b2887894" title="Allocates a new buffer for collection.">fBufAllocForCollection()</a> and set the second parameter to NULL. The application then has everything needed to start reading from the IPFIX source.</p>
<p >Ideally, the application will read the first 4 bytes of the message first to determine the length of the next IPFIX message. The first 2 bytes are the IPFIX version (0x000A) and the third and fourth bytes are the length of the IPFIX message (including these 4 initial bytes). The application should then continue reading the length of the IPFIX message into an allocated octet array. The octet array should then be set on the fBuf by calling <a class="el" href="public_8h.html#a28f24bbb227eb0f2fdd444c8754d9642" title="Sets an octet array on an fBuf for collection.">fBufSetBuffer()</a>.</p>
<p >The application calls <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieves a record from a Buffer associated with a collecting process.">fBufNext()</a> repeatedly to receive the data records until <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieves a record from a Buffer associated with a collecting process.">fBufNext()</a> returns FALSE with error code <a class="el" href="public_8h.html#a2e0ffd43c861a9833b279557d687c57a">FB_ERROR_BUFSZ</a>. This error notifies the application that there is not enough data in the octet array to read a full IPFIX message. However, if the fBuf is in manual mode (see <a class="el" href="public_8h.html#a43af06a2929be582b0d7197f0c13e25a" title="Sets the automatic next-message mode flag on a Buffer.">fBufSetAutomaticNextMessage()</a>) AND the size of the octet array was the IFIX message length, fixbuf will first return an <a class="el" href="public_8h.html#a0259831c04ac6aeee7cb6c96d76b3d65">FB_ERROR_EOM</a> which indicates the application should perform another read (if the application ignores FB_ERROR_EOM errors and calls <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieves a record from a Buffer associated with a collecting process.">fBufNext()</a>, <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieves a record from a Buffer associated with a collecting process.">fBufNext()</a> will then return FB_ERROR_BUFSZ).</p>
<p >If the application octet array was the size of the IPFIX message, the entire octet array should have been processed. However, if the octet array was larger than the IPFIX message length, additional data may remain in the octet array that belongs to the next IPFIX message. To determine how much unprocessed data remains in the octet array, use <a class="el" href="public_8h.html#aee3090cf1b7d116077bb9b627d622fb1" title="When using fBufSetBuffer(), returns the number of unprocessed octets in the octet array.">fBufRemaining()</a>. Any remaining data should be copied to the beginning of the octet array and the remaining IPFIX message data should be read. After each read, the application needs to call <a class="el" href="public_8h.html#a28f24bbb227eb0f2fdd444c8754d9642" title="Sets an octet array on an fBuf for collection.">fBufSetBuffer()</a>. Note that <a class="el" href="public_8h.html#a28f24bbb227eb0f2fdd444c8754d9642" title="Sets an octet array on an fBuf for collection.">fBufSetBuffer()</a> sets the collector and exporter on the fBuf to NULL. The application should clear the <a class="el" href="public_8h.html#a2e0ffd43c861a9833b279557d687c57a">FB_ERROR_BUFSZ</a> and/or <a class="el" href="public_8h.html#a0259831c04ac6aeee7cb6c96d76b3d65">FB_ERROR_EOM</a> error when they occur using g_clear_error().</p>
<p >fixbuf may return the following error codes if it encounters one of the below issues. The application should determine the error and respond appropriately.</p>
<ul>
<li><a class="el" href="public_8h.html#aa225780afc0e4680caf26e0ec9ab2427">FB_ERROR_IPFIX</a><ul>
<li>If the first 2 bytes != 0x000A</li>
<li>If the length in the header &lt; 16</li>
</ul>
</li>
<li><a class="el" href="public_8h.html#a0259831c04ac6aeee7cb6c96d76b3d65">FB_ERROR_EOM</a><ul>
<li>If the application read only the message length and the fBuf is in manual mode). This means the remaining buffer length == 0 and the application should clear the error and perform another read</li>
</ul>
</li>
<li><a class="el" href="public_8h.html#a2e0ffd43c861a9833b279557d687c57a">FB_ERROR_BUFSZ</a><ul>
<li>If the header message length &gt; the given buffer length</li>
<li>if the given buffer == NULL</li>
<li>If the given buffer length &lt; 16</li>
<li>If buffer length == 0</li>
</ul>
</li>
</ul>
<p >Example usage:</p>
<div class="fragment"><div class="line">FILE *fp;</div>
<div class="line">uint8_t buf[65535];</div>
<div class="line">...</div>
<div class="line">while (fread(buf, 1, 4, fp) == 4) {</div>
<div class="line">   len = ntohs(*((uint16_t *)(buf+2)));</div>
<div class="line">   rc = fread(buf+4, 1, len-4, fp);</div>
<div class="line">   <span class="keywordflow">if</span> (rc &gt; 0) {</div>
<div class="line">       <a class="code hl_function" href="public_8h.html#a28f24bbb227eb0f2fdd444c8754d9642">fBufSetBuffer</a>(fbuf, buf, rc+4);</div>
<div class="line">   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (feof(fp))</div>
<div class="line">   ....</div>
<div class="line">   <span class="keywordflow">for</span> (;;) {</div>
<div class="line">       ret = <a class="code hl_function" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7">fBufNext</a>(fbuf, (uint8_t *)rec, &amp;len, &amp;err);</div>
<div class="line">       <span class="keywordflow">if</span> (FALSE == ret) {</div>
<div class="line">          <span class="keywordflow">if</span> (g_error_matches(err, <a class="code hl_define" href="public_8h.html#a16875886e559694c2a5d80cc1b9e00de">FB_ERROR_DOMAIN</a>, <a class="code hl_define" href="public_8h.html#a2e0ffd43c861a9833b279557d687c57a">FB_ERROR_BUFSZ</a>)){</div>
<div class="line">             rem = <a class="code hl_function" href="public_8h.html#aee3090cf1b7d116077bb9b627d622fb1">fBufRemaining</a>(fbuf);</div>
<div class="line">             g_clear_error(&amp;err);</div>
<div class="line">             <span class="keywordflow">break</span>;</div>
<div class="line">          }</div>
<div class="line">       }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="apublic_8h_html_a11c40f1d55e2d4b29b40eb4c07ce5ee7"><div class="ttname"><a href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7">fBufNext</a></div><div class="ttdeci">gboolean fBufNext(fBuf_t *fbuf, uint8_t *recbase, size_t *recsize, GError **err)</div><div class="ttdoc">Retrieves a record from a Buffer associated with a collecting process.</div></div>
<div class="ttc" id="apublic_8h_html_a16875886e559694c2a5d80cc1b9e00de"><div class="ttname"><a href="public_8h.html#a16875886e559694c2a5d80cc1b9e00de">FB_ERROR_DOMAIN</a></div><div class="ttdeci">#define FB_ERROR_DOMAIN</div><div class="ttdoc">All fixbuf errors are returned within the FB_ERROR_DOMAIN domain.</div><div class="ttdef"><b>Definition:</b> public.h:52</div></div>
<div class="ttc" id="apublic_8h_html_a28f24bbb227eb0f2fdd444c8754d9642"><div class="ttname"><a href="public_8h.html#a28f24bbb227eb0f2fdd444c8754d9642">fBufSetBuffer</a></div><div class="ttdeci">void fBufSetBuffer(fBuf_t *fbuf, uint8_t *buf, size_t buflen)</div><div class="ttdoc">Sets an octet array on an fBuf for collection.</div></div>
<div class="ttc" id="apublic_8h_html_a2e0ffd43c861a9833b279557d687c57a"><div class="ttname"><a href="public_8h.html#a2e0ffd43c861a9833b279557d687c57a">FB_ERROR_BUFSZ</a></div><div class="ttdeci">#define FB_ERROR_BUFSZ</div><div class="ttdoc">A message was received larger than the collector buffer size.</div><div class="ttdef"><b>Definition:</b> public.h:80</div></div>
<div class="ttc" id="apublic_8h_html_aee3090cf1b7d116077bb9b627d622fb1"><div class="ttname"><a href="public_8h.html#aee3090cf1b7d116077bb9b627d622fb1">fBufRemaining</a></div><div class="ttdeci">size_t fBufRemaining(fBuf_t *fbuf)</div><div class="ttdoc">When using fBufSetBuffer(), returns the number of unprocessed octets in the octet array.</div></div>
</div><!-- fragment --><p >Previous: <a href="sflow.html">sFlow Collectors</a> | Next: <a href="lists.html">Lists in IPFIX</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</body>
</html>
