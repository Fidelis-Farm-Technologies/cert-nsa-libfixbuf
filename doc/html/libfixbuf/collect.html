<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libfixbuf: Network Collectors</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Network Collectors </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_doc_collect"></a> </p>
<h1><a class="anchor" id="tcp"></a>
How-To Listen Over the Network Using TCP (Recommended)</h1>
<p >An additional type, <a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a>, is used to build Collecting Processes to listen for connections from IPFIX Exporting Processes via the network.</p>
<p >The initial steps to creating a Listener are the same as the previous examples:</p>
<p >First create an <a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> using <a class="el" href="public_8h.html#a23b1973cadfc63b05fabe6091ce48875" title="Allocates a new information model.">fbInfoModelAlloc()</a> and any additional, vendor-specific information elements using <a class="el" href="public_8h.html#a4244c83afec83db26a1924fda60f57de" title="Adds a single information element to an information model.">fbInfoModelAddElement()</a>, <a class="el" href="public_8h.html#ac2b0be79429a02c8026ce7ea8f9ab2e5" title="Adds multiple information elements in an array to an information model.">fbInfoModelAddElementArray()</a>, <a class="el" href="public_8h.html#af72db51fd417df411a82909c5fd5d84d" title="Adds information specified in the given XML file to the information model.">fbInfoModelReadXMLFile()</a>, or <a class="el" href="public_8h.html#a2bbcf6d4a777ed7e0a2c364e0662b9f3" title="Adds information specified in the given XML data to the information model.">fbInfoModelReadXMLData()</a>.</p>
<p >Create an <a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> using <a class="el" href="public_8h.html#a19d0dfe113d61cdabf601ca79c3049c8" title="Allocates an empty transport session state container.">fbSessionAlloc()</a>. Instead of maintaining state for a particular Transport Session, this Session instance is used as a model for each Transport Session created by the Listener. (Each incoming connection is a unique Session. If a single connection contains multiple observation domains, each domain is also a unique Session.)</p>
<p >For each record you expect to receive, create an <a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> via <a class="el" href="public_8h.html#a5a23a76ff4edff6616b5db2fbd63644f" title="Adds a Template to a Session.">fbSessionAddTemplate()</a>, specify its elements (<a class="el" href="public_8h.html#afdf4a52e9f867433d46a1d4d8ec4bc8f" title="Appends information elements described by a specifier array to a template.">fbTemplateAppendSpecArray()</a>, <a class="el" href="public_8h.html#aa26aa2d6a6b57dba79d2b5742b4a7540" title="Potentially appends an information element described by the specifier to a template.">fbTemplateAppendSpec()</a>, or <a class="el" href="public_8h.html#a72db5a960f00cd94e223d0fc6b7df0a4" title="Appends an information element to a template.">fbTemplateAppend()</a>), and add it as an internal Template to the Session uinsg <a class="el" href="public_8h.html#a5a23a76ff4edff6616b5db2fbd63644f" title="Adds a Template to a Session.">fbSessionAddTemplate()</a>.</p>
<p >To specify the host and port where the Listener should wait for connections, define an <a class="el" href="public_8h.html#a3a56c4420baffe7f4d483231a33cd25c">fbConnSpec_t</a> object.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="public_8h.html#structfb_conn_spec__st">fbConnSpec_t</a> connspec;</div>
<div class="line">memset(&amp;connspec, 0, <span class="keyword">sizeof</span>(connspec));</div>
<div class="line">connspec.<a class="code hl_variable" href="public_8h.html#a849be540114f29513354946d52b2fa11">transport</a> = <a class="code hl_enumvalue" href="public_8h.html#a42b75e3dc15f6c6ebb447598eb7d9338a3d0d039b439e58056f0318fc8d40f69e">FB_TCP</a>;</div>
<div class="line">connspec.<a class="code hl_variable" href="public_8h.html#ac26334ce688042ba9296b5a07ea65332">host</a> = <span class="stringliteral">&quot;127.0.0.1&quot;</span>;</div>
<div class="line">connspec.port = <span class="stringliteral">&quot;4739&quot;</span>;</div>
<div class="ttc" id="apublic_8h_html_a42b75e3dc15f6c6ebb447598eb7d9338a3d0d039b439e58056f0318fc8d40f69e"><div class="ttname"><a href="public_8h.html#a42b75e3dc15f6c6ebb447598eb7d9338a3d0d039b439e58056f0318fc8d40f69e">FB_TCP</a></div><div class="ttdeci">@ FB_TCP</div><div class="ttdoc">Reliable stream transport via TCP.</div><div class="ttdef"><b>Definition:</b> public.h:1721</div></div>
<div class="ttc" id="apublic_8h_html_a849be540114f29513354946d52b2fa11"><div class="ttname"><a href="public_8h.html#a849be540114f29513354946d52b2fa11">fbConnSpec_st::transport</a></div><div class="ttdeci">fbTransport_t transport</div><div class="ttdoc">Transport protocol to use.</div><div class="ttdef"><b>Definition:</b> public.h:1749</div></div>
<div class="ttc" id="apublic_8h_html_ac26334ce688042ba9296b5a07ea65332"><div class="ttname"><a href="public_8h.html#ac26334ce688042ba9296b5a07ea65332">fbConnSpec_st::host</a></div><div class="ttdeci">char * host</div><div class="ttdoc">Hostname to connect/listen to.</div><div class="ttdef"><b>Definition:</b> public.h:1751</div></div>
<div class="ttc" id="apublic_8h_html_structfb_conn_spec__st"><div class="ttname"><a href="public_8h.html#structfb_conn_spec__st">fbConnSpec_st</a></div><div class="ttdoc">Connection specifier.</div><div class="ttdef"><b>Definition:</b> public.h:1747</div></div>
</div><!-- fragment --><p >Create the <a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> using the <a class="el" href="public_8h.html#adbd1257997f1905c580a77fe01b26ec4" title="Allocates a listener.">fbListenerAlloc()</a> call. The Listener encapsulates a passive socket on the network that waits for connections from Exporting Processes.</p>
<p >To wait for a connection, call <a class="el" href="public_8h.html#a68303972f3934cd1c7000486924af510" title="Waits on a listener.">fbListenerWait()</a>. When a new connection arrives, the function clones the <a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a>, creates an <a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a>, and creates a Buffer (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a>) for reading from that Collector, and returns the newly created Buffer.</p>
<p >A Listener binds to each address returned by getaddrinfo(). Once a packet is received from an address, the Collector only reads packets on that address UNLESS <a class="el" href="public_8h.html#a68303972f3934cd1c7000486924af510" title="Waits on a listener.">fbListenerWait()</a> is called again. If the application is expecting multiple connections or IPFIX records from multiple IPFIX (UDP) exporters, the application should put the <a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> returned from <a class="el" href="public_8h.html#a68303972f3934cd1c7000486924af510" title="Waits on a listener.">fbListenerWait()</a> into to manual mode by calling <a class="el" href="public_8h.html#a43af06a2929be582b0d7197f0c13e25a" title="Sets the automatic next-message mode flag on a Buffer.">fBufSetAutomaticNextMessage()</a> with FALSE as the second argument and handle <a class="el" href="public_8h.html#a0259831c04ac6aeee7cb6c96d76b3d65">FB_ERROR_EOM</a> errors returned from <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieves a record from a Buffer associated with a collecting process.">fBufNext()</a> by calling <a class="el" href="public_8h.html#a68303972f3934cd1c7000486924af510" title="Waits on a listener.">fbListenerWait()</a> again.</p>
<p >Each Listener tracks every active collector/buffer (i.e., each active Session) it created; the <a class="el" href="public_8h.html#a68303972f3934cd1c7000486924af510" title="Waits on a listener.">fbListenerWait()</a> call returns an fBuf_t from which another IPFIX Message may be read if no new connections are available. To minimize switching among available Sessions, the most recent fBuf_t is returned if it has data available.</p>
<p >The application may also use <a class="el" href="public_8h.html#a72f4ae91f7f0dc67a38eb5694be4605d" title="Waits for an incoming connection, just like fbListenerWait(), except that this function does not moni...">fbListenerWaitNoCollectors()</a> to handle only the initial accepting of a connection (for TCP). Once an <a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> and its associated <a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> are returned by this function, that connection is ignored by subsequent calls to <a class="el" href="public_8h.html#a72f4ae91f7f0dc67a38eb5694be4605d" title="Waits for an incoming connection, just like fbListenerWait(), except that this function does not moni...">fbListenerWaitNoCollectors()</a> for the duration of the connection.</p>
<p >If an application wants to wait for connections on multiple ports or multiple transport protocols, the application may use <a class="el" href="public_8h.html#a4384bc78814aa74f85ed30c09b14c407" title="Accepts connections for multiple listeners.">fbListenerGroupWait()</a> to accept multiple connections. The application should create separate a <a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> and <a class="el" href="public_8h.html#a3a56c4420baffe7f4d483231a33cd25c">fbConnSpec_t</a> for each fbListener_t and call <a class="el" href="public_8h.html#adbd1257997f1905c580a77fe01b26ec4" title="Allocates a listener.">fbListenerAlloc()</a> to allocate each listener. Allocate an <a class="el" href="public_8h.html#aa08258f227730a0c2bba1fffeac382d1">fbListenerGroup_t</a> (<a class="el" href="public_8h.html#afa82bcb623b0026d823bc7aba6a7610e" title="Allocates and returns an empty ListenerGroup.">fbListenerGroupAlloc()</a>) and add each Listener to the Group using <a class="el" href="public_8h.html#a5b5716c8fe63a2f982e32a98eed0e38f" title="Adds a previously allocated listener to the previously allocated group.">fbListenerGroupAddListener()</a>. Instead of calling <a class="el" href="public_8h.html#a68303972f3934cd1c7000486924af510" title="Waits on a listener.">fbListenerWait()</a>, use <a class="el" href="public_8h.html#a4384bc78814aa74f85ed30c09b14c407" title="Accepts connections for multiple listeners.">fbListenerGroupWait()</a> to listen on all addresses in the Group. <a class="el" href="public_8h.html#a4384bc78814aa74f85ed30c09b14c407" title="Accepts connections for multiple listeners.">fbListenerGroupWait()</a> returns an <a class="el" href="public_8h.html#aae51a493368af916fd3bc701cb8e9383">fbListenerGroupResult_t</a> which is a linked list of results. The fbListenerGroupResult_t contains a pointer to an fBuf_t and the fbListener_t that created the fBuf_t as well as a pointer to the next result, if available. Use <a class="el" href="public_8h.html#a620984c30070a7b3a1da81d1f84d798d" title="Frees the listener group result returned from fbListenerGroupWait().">fbListenerFreeGroupResult()</a> to free the result when <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieves a record from a Buffer associated with a collecting process.">fBufNext()</a> has been called on each fBuf_t.</p>
<p >Additionally, the application can use <a class="el" href="public_8h.html#ac9d2c94ddb32fa9ff187fdfe0e9358d9" title="Returns an fBuf wrapped around an independently managed socket and a properly created listener for TC...">fbListenerOwnSocketCollectorTCP()</a> to provide its own socket for listening instead of libfixbuf creating one for it.</p>
<p >To reject incoming connections, the application should use the <a class="el" href="public_8h.html#a4313f40737bf2a6ab1db94693119312c">fbListenerAppInit_fn</a> function callback. This will be called right after accept() is called (in the TCP case). The application can veto the connection by returning FALSE. Once the connection is vetoed, fixbuf will not listen on that socket descriptor. If the appinit() function should reject a connection the application should set the error code to FB_ERROR_NLREAD and the application should ignore FB_ERROR_NLREAD error codes. The appinit() function works slightly differently for UDP. See the <a href="udp.html">UDP instructions</a> for how to use appinit() for collecting IPFIX over UDP.</p>
<p >Previous: <a href="templates.html">Template Definition</a> | Next: <a href="udp.html">UDP Collectors</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</body>
</html>
